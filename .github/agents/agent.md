---
description: 'Describe what this custom agent does and when to use it.'
tools: ['runCommands', 'runTasks', 'edit', 'runNotebooks', 'search', 'new', 'extensions', 'todos', 'runSubagent', 'usages', 'vscodeAPI', 'problems', 'changes', 'testFailure', 'openSimpleBrowser', 'fetch', 'githubRepo']
---
ws-scrcpy Agents
This repository turns a browser into a remote control surface for Android and optionally iOS devices by bridging Genymobile's scrcpy streaming server with a Node.js gateway and a rich web UI. The codebase is organized around a handful of long-lived agents with clear responsibilities that cooperate over WebSockets, ADB, and HTTP. This document summarizes each agent, the modules that implement it, and the major flows tying them together.

System Goal:
1) Detect devices connected to a host, either USB or network, and keep their metadata fresh.
2) Spin up or reuse a WebSocket-enabled scrcpy server on each Android device.
3) Expose device capabilities to browsers through a single Node.js endpoint that serves the UI, proxies traffic, and multiplexes side channels such as shell, devtools, and file listing.
4) Let the browser stream video, inject input events, push files, open shells, and inspect WebViews using pluggable players and tools.

Primary Agents:
Android Device Agent keeps scrcpy running on each device, tracks interfaces, and exposes adb-powered helpers such as shell, devtools, and file operations using src/server/goog-device/Device.ts, ScrcpyServer.ts, AdbUtils.ts, and vendor/Genymobile/scrcpy.
Node Gateway Agent boots HTTP plus WebSocket servers, loads middleware, manages trackers, multiplexes channels, and proxies remote hosts via src/server/index.ts, services/HttpServer.ts, services/WebSocketServer.ts, mw/*.ts, server/goog-device/**/*, and server/appl-device/**/*.
Browser Client Agent hosts the UI, device list, stream players, interaction handlers, tooling overlays, and persistence using src/app/index.ts, app/client/**/*.ts, app/googDevice/**/*.ts, app/player/**/*, and style/*.css.
Optional iOS Agent mirrors the Android flow using WebDriverAgent, ws-qvh, or MJPEG for capture and inputs through src/server/appl-device/**, src/app/applDevice/**, and config flags.
Multiplexer and Shared Infrastructure share a single WebSocket transport between logical channels such as host tracking, trackers, shell, and file access, unifying typed messages via packages/multiplexer/**, common/*.ts, and types/*.ts.

Android Device Agent:
Lifecycle management relies on ControlCenter in src/server/goog-device/services/ControlCenter.ts to watch adb trackers, instantiate a Device per UDID, and emit descriptors consumed by trackers. Server bootstrap is handled when Device.startServer delegates to ScrcpyServer.run, which copies scrcpy-server.jar from vendor/Genymobile/scrcpy, executes it with ARGS_STRING from src/common/Constants.ts, and polls PID files until WebSockets are live. State reporting collects build properties, surfaces network interfaces, and discovers TCP endpoints that expose scrcpy so descriptors align with types/GoogDeviceDescriptor.d.ts and include PIDs and Wi-Fi interface names. ADB utilities in AdbUtils handle TCP forwarding, file stats, pulling and pushing, devtools socket inspection, and piping shell or listing responses back through multiplexer channels.

Node Gateway Agent:
The entry point in src/server/index.ts loads Config.ts, instantiates HttpServer to serve dist/public and optional MJPEG proxy, and creates WebSocketServer on the same ports while lazily importing Android or iOS services based on build flags. The middleware chain expects an action query parameter on WebSocket requests so WebSocketServer hands sockets to registered middleware defined in mw/Mw.ts. WebsocketProxy under ACTION.PROXY_WS mirrors raw WebSockets to arbitrary upstreams, while WebsocketMultiplexer under ACTION.MULTIPLEX upgrades sockets to the custom multiplexing protocol so logical channels such as HostTracker, DeviceTracker, shell, and file listing can coexist. HostTracker with channel code HSTS sends the list of available local or remote trackers as soon as a multiplexer channel opens, and Android-specific middleware in server/goog-device/mw binds channel codes to capabilities like device listing (GTRC), shell, devtools, file listing, and WebSocket proxy over adb. The control loop lets ControlCenter and Device act as an internal agent supervising devices, where commands flow from browser to tracker channel to ControlCenterCommand, then ControlCenter.runCommand, and finally Device methods. Host federation uses Config.remoteHostList so HostTracker can advertise additional endpoints and the browser can launch trackers pointed at those hosts with optional proxying.

Browser Client Agent:
Bootstrap work in src/app/index.ts loads CSS, optional decoders such as Broadway, MSE, TinyH264, and WebCodecs, and starts the Tool registry plus HostTracker. Device discovery happens when HostTracker in app/client/HostTracker.ts opens an ACTION.LIST_HOSTS multiplexer channel, receives available host descriptors, and launches platform trackers; BaseDeviceTracker renders the responsive device list UI, and googDevice/client/DeviceTracker.ts wires Android-specific controls like interface selection, PID actions, and stream links. The streaming agent pairs StreamClientScrcpy with StreamReceiverScrcpy to manage video and control channels, where StreamReceiver handles binary framing by reading the initial scrcpy metadata blob containing device name, display list, other clients, and encoders before ingesting H.264 frames or device messages, then replays cached control messages once connected. Players and interactions rely on implementations in app/player/*, while input is captured via interactionHandler/FeaturedInteractionHandler, KeyInputHandler, and controlMessage classes that serialize gestures and keycodes back to the device; file pushes use filePush classes and ScrcpyFilePushStream, reusing the stream receiver transport. The toolbox composed of GoogToolBox, GoogMoreBox, and Tool plugins adds UI sections for shell terminals, devtools listings, file managers, and similar features that mirror available middleware. State and routing depend on stream links embedding parameters in the hash such as #!/action=stream&udid=..., and BaseClient.parseParameters normalizes query strings so proxying or secure WebSockets work consistently.

Optional iOS Agent:
Webpack flags like INCLUDE_APPL, USE_QVH_SERVER, and USE_WDA_MJPEG_SERVER control whether the server loads src/server/appl-device services to talk to WebDriverAgent or ws-qvh and whether the client mirrors the Android tracker and streamer pattern inside src/app/applDevice. Interactions are currently limited to taps, scrolls, and home button events routed through WebDriverAgent, with instructions in the README.

Multiplexer and Shared Infrastructure:
A single TCP or WebSocket connection hosts multiple logical channels through packages/multiplexer/Multiplexer.ts, where channels advertise a four byte code defined in common/ChannelCode.ts so both Node middleware and browser clients know which handler to attach. ManagerClient and BaseDeviceTracker encapsulate client-side multiplexer use, automatically reusing sockets, buffering outbound messages until the connection is open, and wrapping channel metadata. Typed messages and DTOs reside under src/common and src/types to keep serialization consistent across agents.

End-to-End Flows:
Device discovery starts when the browser connects to /ws?action=multiplex and the HostTracker channel HSTS responds with the available trackers; for Android, DeviceTracker on channel GTRC subscribes to ControlCenter updates whose descriptors include PID and network info so the UI can present buttons for starting or killing the server, proxying over adb, or streaming directly. Starting a stream involves selecting an interface that emits an ACTION.STREAM_SCRCPY link; if the browser cannot reach the device, the link may include useProxy=true to wrap the target URL in a proxy-ws action riding the Node gateway and optionally an adb port-forward via WebsocketProxyOverAdb. StreamReceiverScrcpy connects to the scrcpy WebSocket at ws://device:8886 or a proxied endpoint, receives the initial metadata blob, negotiates VideoSettings such as bitrate, bounds, and encoder choice, and begins ingesting H.264 NAL units while user input travels back as ControlMessages on the same socket. Secondary channels include remote shell via ACTION.SHELL spawning RemoteShell middleware to bridge node-pty to adb shell sessions rendered by xterm.js, devtools via RemoteDevtools using AdbUtils.getRemoteDevtoolsInfo to fetch /json metadata from Chrome instances and rewrite WebSocket URLs for inspection, and file listing or transfer via FileListing middleware that streams directory stats and file payloads so the UI can drag-and-drop uploads with AdbUtils.push or download files through pipePullFileToStream.

Build and Run Time Controls:
Webpack flags in webpack/default.build.config.json and build.config.override.json decide which agents compile into the bundle, allowing tree shaking to keep unused features out of production builds. Runtime environment variables like WS_SCRCPY_CONFIG and WS_SCRCPY_PATHNAME select config files and the base path, while the YAML config manages listening ports, TLS certificates, and remote host lists.

Security Notes:
The README explains that the current setup lacks transport encryption and authentication between the browser, Node gateway, and on-device WebSocket server. When exposing the gateway beyond a trusted LAN, add HTTPS or TLS at the Node layer, restrict access to port 8886 on devices, and consider fronting the service with an authenticated proxy.

Where to Go Next:
Follow the ASCII diagram in docs/scheme.md to visualize the topology, use docs/debug.md for adb debugging tips, consult docs/Devtools.md for remote inspection workflows, and when extending the system, decide which agent should own the feature before adding the corresponding middleware and client tool pair.
